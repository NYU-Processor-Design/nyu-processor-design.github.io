## Week of 10 September 2023

Project Work:
  * [Onboarding Lab 1](https://github.com/hahacharlie/week-one-lab): Completed Lab 1

Week 1 Lab Questions:
  * The paths used by target_sources and target_include_directories are relative, not absolute. What file or folder are they relative to?
    * These paths are considered relative to the location of the `CMakeLists.txt` file in which the command is called. 

  * What are some differences between cmake and ninja?
    * Both `ninja` and `make` are build systems, but they have distinct characteristics, purposes, and histories. Here's a comparison:

      1. **Origins & Design Goals**:
          - `Make`: Introduced in 1976, `make` is one of the earliest build systems. It's designed to determine which parts of a large program need to be recompiled and issue commands to recompile them. It uses `Makefile` to specify how to derive the target program from the source files.
          - `ninja`: A relatively newer build system, `ninja` is designed to be faster and more scalable than `make`. It arose from the need to scale builds for large codebases like Chrome. The focus is on speed and efficiency. It uses `build.ninja` files which are typically generated by higher-level meta-build systems like CMake or Meson.

      2. **File Format**:
          - `Make`: Uses `Makefile` with its specific syntax.
          - `ninja`: Uses `build.ninja` with its simpler, non-Turing-complete syntax. These files are often generated by another system, so developers rarely write them by hand.

      3. **Performance**:
          - `make`: Can be slower, especially for large codebases. It's not always efficient with parallel builds.
          - `ninja`: Designed for performance. It can quickly determine what needs to be rebuilt and does so efficiently. This makes it especially suitable for large projects.

      4. **Usability**:
         - `make`: While `make` is powerful, its syntax can be complex and error-prone for large projects. It has various implementations (GNU Make, BSD Make, etc.) which might have subtle differences.
         - `ninja`: Has a simpler, more streamlined syntax. However, because the `build.ninja` files are usually generated by other tools, end-users don't often need to interact directly with the `ninja` syntax.

      5. **Features**:
          - `make`: Offers a plethora of built-in functions, pattern rules, and other features that can make Makefiles complex.
          - `ninja`: Intentionally minimal in design. It defers higher-level functionalities to other systems (like CMake).

      6. **Dependency Discovery**:
         - `make`: Dependencies are typically specified in the Makefile, or generated via tools like `gcc -M` for C/C++ header dependencies.
         - `ninja`: Relies on the tool that generates the `build.ninja` file to determine dependencies. For example, CMake can use `gcc -M` style dependency discovery and then encode this into the generated `build.ninja`.

      7. **Integration**:
         - `make`: Supported by many systems out of the box. It's the default for many open-source projects.
         - `ninja`: Increasingly integrated into modern build systems. For instance, CMake can generate build files for both `make` and `ninja`.

     * In summary, while both `ninja` and `make` serve similar roles, they represent different points in the evolution of build systems. `make` is older and more ubiquitous, but for large-scale modern projects where performance is critical, `ninja` often has the edge. However, it's worth noting that many developers today interact with these systems through higher-level tools like CMake or Meson, which abstract away the underlying build system.

  * Why is it important to run cmake in its own directory?
    * Running `cmake` in its own directory, often referred to as an "out-of-source" build, is a recommended practice for several reasons:

      1. **Clean Source Tree**: By keeping the build files separate from the source files, your source directory remains clean. This means there are no build artifacts mixed in with your actual source code, which makes the directory easier to navigate and manage.

      2. **Multiple Builds with Different Configurations**: With out-of-source builds, you can easily maintain multiple build configurations simultaneously. For example, you can have one directory for a Debug build, another for a Release build, and so on, without them interfering with each other.

      3. **Easy Cleanup**: If you want to start your build from scratch, you can simply delete the build directory and create it again. This is much easier and safer than trying to remove individual build artifacts from the source directory.

      4. **Version Control**: It's easier to ignore build artifacts in version control systems (like git) when all the build files are in a separate directory. Typically, the entire build directory is ignored, ensuring that no temporary build files accidentally get committed.

      5. **Reduces Mistakes**: In-source builds can sometimes lead to mistakes where important source files are overwritten or deleted, especially if filenames collide.

      6. **Portable**: By keeping build artifacts separate from the source, it becomes easier to move, share, or archive the source code without transferring unnecessary build files.

      7. **Tool Compatibility**: Some tools might make assumptions based on the presence or absence of build files in the source directory. Keeping the source directory clean ensures better compatibility with various tools and scripts.

    * By following this approach, all the generated build files will be inside the `build` directory, keeping the source directory untouched and clean.