# Lucy's Design Notebook

## Week 1: 09/08/2025 - 09/14/2025

* Worked through "Design Notebooks and Git" and "Development Environment" on the VIP website
* Completed "Getting Started" and "Verilog Language: Basics" on HDLBits

WSL and Ubuntu (and packages) were downloaded using the Windows Powershell terminal. There were no problems in this process.
The HDLBits problem sets were a great refresher for me and it does explain in more detail on how Verilog works compared to a circuit.

I am using VS Code for the first time, so I had a hard time navagating the files and learning how to use VS Code with Ubuntu. I hard a hard time creating a branch in my fork repository and could not tell where I was in the repository (main or branch) until I searched up the documentation for [Git source control in VS Code](https://code.visualstudio.com/docs/sourcecontrol/overview).

**Remaining Questions:** I am still kind of confused with how Ubuntu works with VS Code and where the files are stored (locally?).

## Week 2: 09/15/2025 - 09/21/2025

* Completed Program Counter with my partner

We read the documentations on the [instruction set](https://user.eng.umd.edu/~blj/risc/RiSC-isa.pdf) and [sequential implementation of the RiSC-16 chip](https://user.eng.umd.edu/~blj/risc/RiSC-seq.pdf). However, we were having trouble understanding what the inputs and outputs should be for the PC. 

1. One idea was that the 16-bit instruction set in machine code is passed into the module, but that idea was discarded because there was no way of obtaining the addresses of the registers and immediate value through the machine code. 
2. Another idea was that the opcode, registers, and immediate values are passed into the module as inputs and we would use the opcode to decide on what the output address would be. But, we were unsure on how the incrementation of the PC would work and how the address would be chosen, given two 3-bit registers (A and B).

We consulted Noah about the inputs and outputs of the PC. From my interpretation, he explained that there are 3 possible jumps for the output address: incrementing of 1, jumping to register B (JALR instruction), and jumping to the immediate value (BEQ instruction). For all 3 possible jumps, there should be an input with the 16-bit address. A multiplexer, given an input from another module, is used to choose which address would be the one the PC would actually point to.

My partner and I had some differences in our interpretations, so we decided to write our code in separate files and push both versions to the repository ([Mine](https://github.com/Ghqlq/Processor-Design-Projects/blob/main/program_counter_2.v) and [My Partner's](https://github.com/Ghqlq/Processor-Design-Projects/blob/main/program_counter.v)).

**Remaining Questions/Notes:** We are unable to test our PC implementations, so we are not sure if either of them are correct. Since we are both taking Computer Architecture this semester, we are not yet sure how the ALU, PC, instruction memory, etc. work together.

## Week 3: 09/22/2025 - 09/29/2025

* Fixed PC to pass all testbench tests
* Completed ALU and passed the testbench tests

The [sequential implementation document](https://user.eng.umd.edu/~blj/risc/RiSC-seq.pdf) was reviewed to understand how the inputs (given in the slides) were manipulated to be passed into the multiplexers. Since there are four possible operations to choose from&mdash;add, bitwise nand, passing src1, and setting EQ if equal&mdash;the input FUNC_alu is 2-bits. 

The multiplexers inputs are 1-bit signals that choose whether the left-shifted immediate value or the source1 input [MUX_alu1] and the whether the sign-extended immediate value or the source2 input [MUX_alu2] are used as the source inputs for the internal multiplexer of the ALU that operates on the two inputs.

The outputs, EQ (1-bit) and alu_out (16-bit), are selected based on the following operations:
- **default:** alu_out = 16'b0, EQ = 1'b0
- **add:** alu_out = src1 + src2
- **bitwise nand:** alu_out = ~(src1 & src2)
- **passing src1 unchanged:** alu_out = src1
- **setting EQ:** alu_out = 16'b0

EQ is always being set to (src1 == src2) for every operation.

For this week's project, my partner and I worked separately, meeting once to check each other's progress. Therefore, we worked on separate alu files: [Mine](https://github.com/Ghqlq/Processor-Design-Projects/blob/main/alu2.v) and [My Partner's](https://github.com/Ghqlq/Processor-Design-Projects/blob/main/alu.v).

**Remaining Question:** When fixing the PC, I was confused on why the reset input is negative and why the immediate value is inputted as 7-bit, not 16-bit.
When working on the ALU, I had the following questions: When do you decide to make an input/output a register? When do you use a clock and when do you not (depending on if it iterates?).

## Week 4: 09/30/2025 - 10/05/2025

* Completed the Register File
* Fixed Register File to pass all test cases in the testbench

The [Instruction Set Architecture](https://user.eng.umd.edu/~blj/risc/RiSC-isa.pdf) was reviewed. The 16-bit instruction input was separated into different variables: opCode, rA, rB, rC, signed_imm, and imm. An array of eight 16-bit registers was created. 

At first, I thought the opcode would be used to assign the results (rB + rC, rB nand rC, etc) to rA. But, I realized that the calculations are done in the ALU, so the register value should be updated with the values inputted to the register file (alu_out, mem_out, pc). 

Looking at the diagram in the Instruction Set Architecture, I think the MUX_tgt is used to determine what value the destination register is updated with, if the WE bit is turned on. The outputs for the register file are determined on the opcode of the inputted instruction.

### Testing code with Testbench
There were many syntax and logic errors while testing my code with the testbench. Below are the things I realized and fixed.
* MUX_rf: used to determine if reg_out2 is rA or rC
* The default case is to output 16'b0 for both outputs
* Need to extend the signed_imm and the 10-bit imm for reg_out2
* The register file only updates if:
    1) WE_rf bit is on
    2) source register is not register 0

[Link to the Code](https://github.com/Ghqlq/Processor-Design-Projects/blob/main/register2.v)

**Notes:** As I am writing this week's design notebook, I realize that it doesn't make sense to update the register using the value of the current instruction's rA. So, I am unsure as to why my current code (which does the above) passes all the test cases.