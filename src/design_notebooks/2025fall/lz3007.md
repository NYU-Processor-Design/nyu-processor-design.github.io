# Lucy's Design Notebook

## Week 1: 09/08/2025 - 09/14/2025

* Worked through "Design Notebooks and Git" and "Development Environment" on the VIP website
* Completed "Getting Started" and "Verilog Language: Basics" on HDLBits

WSL and Ubuntu (and packages) were downloaded using the Windows Powershell terminal. There were no problems in this process.
The HDLBits problem sets were a great refresher for me and it does explain in more detail on how Verilog works compared to a circuit.

I am using VS Code for the first time, so I had a hard time navagating the files and learning how to use VS Code with Ubuntu. I hard a hard time creating a branch in my fork repository and could not tell where I was in the repository (main or branch) until I searched up the documentation for [Git source control in VS Code](https://code.visualstudio.com/docs/sourcecontrol/overview).

**Remaining Questions:** I am still kind of confused with how Ubuntu works with VS Code and where the files are stored (locally?).

## Week 2: 09/15/2025 - 09/21/2025

* Completed Program Counter with my partner

We read the documentations on the [instruction set](https://user.eng.umd.edu/~blj/risc/RiSC-isa.pdf) and [sequential implementation of the RiSC-16 chip](https://user.eng.umd.edu/~blj/risc/RiSC-seq.pdf). However, we were having trouble understanding what the inputs and outputs should be for the PC. 

1. One idea was that the 16-bit instruction set in machine code is passed into the module, but that idea was discarded because there was no way of obtaining the addresses of the registers and immediate value through the machine code. 
2. Another idea was that the opcode, registers, and immediate values are passed into the module as inputs and we would use the opcode to decide on what the output address would be. But, we were unsure on how the incrementation of the PC would work and how the address would be chosen, given two 3-bit registers (A and B).

We consulted Noah about the inputs and outputs of the PC. From my interpretation, he explained that there are 3 possible jumps for the output address: incrementing of 1, jumping to register B (JALR instruction), and jumping to the immediate value (BEQ instruction). For all 3 possible jumps, there should be an input with the 16-bit address. A multiplexer, given an input from another module, is used to choose which address would be the one the PC would actually point to.

My partner and I had some differences in our interpretations, so we decided to write our code in separate files and push both versions to the repository ([Mine](https://github.com/Ghqlq/Processor-Design-Projects/blob/main/program_counter_2.v) and [My Partner's](https://github.com/Ghqlq/Processor-Design-Projects/blob/main/program_counter.v)).

**Remaining Questions/Notes:** We are unable to test our PC implementations, so we are not sure if either of them are correct. Since we are both taking Computer Architecture this semester, we are not yet sure how the ALU, PC, instruction memory, etc. work together.